require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

# Capture react-native path at parse time for use in pre_install hook
$react_native_path = File.dirname(`node --print "require.resolve('react-native/package.json')"`.strip)
$codegen_script_path = "#{$react_native_path}/scripts/generate-codegen-artifacts.js"

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

def ccache_enabled?(podfile_properties)
  # Environment variable takes precedence
  return ENV['USE_CCACHE'] == '1' if ENV['USE_CCACHE']
  
  # Fall back to Podfile properties
  podfile_properties['apple.ccacheEnabled'] == 'true'
end

ENV['RCT_NEW_ARCH_ENABLED'] ||= '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] ||= podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']
ENV['RCT_USE_RN_DEP'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
ENV['RCT_USE_PREBUILT_RNCORE'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'

prepare_react_native_project!

target 'Nekt' do
# @generated begin Generated by react-native-app-clip - expo prebuild (DO NOT MODIFY) sync-61d97f89731eb23eebfcb69545ba3ad1f37a1bd3

  target 'NektClip' do
    exclude = ["react-native-reanimated", "react-native-worklets", "expo-contacts", "expo-location", "expo-sensors", "expo-dev-client", "expo-auth-session", "expo-web-browser", "expo-crypto", "expo-file-system", "expo-keep-awake", "react-native-qrcode-svg", "react-native-markdown-display", "expo-calendar", "react-native-ble-plx"]
    use_expo_modules!(exclude: exclude)

    if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
      config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
    else
      config_command = [
        'npx',
        'expo-modules-autolinking',
        'react-native-config',
        '--json',
        '--platform',
        'ios'
      ]
    end

    # Running the command in the same manner as `use_react_native` then running that result through our cliPlugin
    json, message, status = Pod::Executable.capture_command(config_command[0], config_command[1..], capture: :both)
    if not status.success?
      Pod::UI.warn "The command: '#{config_command.join(" ").bold.yellow}' returned a status code of #{status.exitstatus.to_s.bold.red}, #{message}", [
          "App Clip autolinking failed. Please ensure autolinking works correctly for the main app target and try again.",
      ]
      exit(status.exitstatus)
    end

    # `react-native-app-clip` resolves to react-native-app-clip/build/index.js
    clip_command = [
      'node',
      '--no-warnings',
      '--eval',
      'require(require.resolve(\'react-native-app-clip\')+\'/../../plugin/build/cliPlugin.js\').run(' + json + ', ["react-native-reanimated", "react-native-worklets", "expo-contacts", "expo-location", "expo-sensors", "expo-dev-client", "expo-auth-session", "expo-web-browser", "expo-crypto", "expo-file-system", "expo-keep-awake", "react-native-qrcode-svg", "react-native-markdown-display", "expo-calendar", "react-native-ble-plx"])'
    ]

    config = use_native_modules!(clip_command)

    use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
    use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

    use_react_native!(
      :path => config[:reactNativePath],
      :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
      # An absolute path to your application root.
      :app_path => "#{Pod::Config.instance.installation_root}/..",
      :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
    )
  end
      
# @generated end Generated by react-native-app-clip
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'node',
      '--no-warnings',
      '--eval',
      'require(\'expo/bin/autolinking\')',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  # Pre-install hook to generate codegen for third-party libraries
  # React Native's built-in codegen discovery doesn't work with Bun's package manager structure
  pre_install do |installer|
    Pod::UI.puts "[Custom Codegen] Starting codegen generation for third-party libraries..."

    # Use paths captured at parse time (stored in global variables at top of Podfile)
    codegen_script = $codegen_script_path

    # ios_native_path is one level up from the ios directory
    ios_native_path = File.expand_path('..', Pod::Config.instance.installation_root)
    output_dir = '/tmp/codegen-output'

    Pod::UI.puts "[Custom Codegen] React Native path: #{$react_native_path}"
    Pod::UI.puts "[Custom Codegen] Codegen script: #{codegen_script}"
    Pod::UI.puts "[Custom Codegen] iOS native path: #{ios_native_path}"

    if File.exist?(codegen_script)
      Pod::UI.puts "[Custom Codegen] Found codegen script at: #{codegen_script}"

      begin
        # Generate codegen - run from ios-native directory
        result = system("cd '#{ios_native_path}' && node '#{codegen_script}' --path . --targetPlatform ios --outputPath '#{output_dir}'")
        Pod::UI.puts "[Custom Codegen] Codegen script returned: #{result}"

        # Copy generated files to ios project
        source_dir = "#{output_dir}/build/generated/ios"
        dest_dir = "#{ios_native_path}/ios/build/generated/ios"

        if File.exist?(source_dir)
          FileUtils.mkdir_p(dest_dir)
          FileUtils.cp_r("#{source_dir}/.", dest_dir)
          Pod::UI.puts "[Custom Codegen] Copied codegen files to: #{dest_dir}"

          # List generated files
          generated_files = Dir.entries(dest_dir).reject { |f| f.start_with?('.') }
          Pod::UI.puts "[Custom Codegen] Generated files: #{generated_files.join(', ')}"
        else
          Pod::UI.warn "[Custom Codegen] Source directory not found: #{source_dir}"
        end
      rescue => e
        Pod::UI.warn "[Custom Codegen] Codegen generation failed: #{e.message}"
      end
    else
      Pod::UI.warn "[Custom Codegen] Codegen script not found at: #{codegen_script}"
    end

    Pod::UI.puts "[Custom Codegen] Done."
  end

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => ccache_enabled?(podfile_properties),
    )

    # Fix codegen header search paths for third-party Fabric components
    codegen_path = "#{Pod::Config.instance.installation_root}/build/generated/ios"
    yoga_path = File.expand_path(File.join(config[:reactNativePath], 'ReactCommon', 'yoga'), Pod::Config.instance.installation_root)
    extra_header_paths = "\"#{codegen_path}\" \"#{yoga_path}\""

    installer.pods_project.targets.each do |target|
      target.build_configurations.each do |build_config|
        existing_paths = build_config.build_settings['HEADER_SEARCH_PATHS'] || '$(inherited)'
        if existing_paths.is_a?(Array)
          existing_paths = existing_paths.join(' ')
        end
        build_config.build_settings['HEADER_SEARCH_PATHS'] = "#{existing_paths} #{extra_header_paths}"

        # Disable Folly coroutines - RCT-Folly doesn't include coro headers
        existing_cflags = build_config.build_settings['OTHER_CPLUSPLUSFLAGS'] || '$(inherited)'
        if existing_cflags.is_a?(Array)
          existing_cflags = existing_cflags.join(' ')
        end
        build_config.build_settings['OTHER_CPLUSPLUSFLAGS'] = "#{existing_cflags} -DFOLLY_CFG_NO_COROUTINES=1"
      end
    end

    # Fix codegen header paths in xcconfig files for third-party pods
    codegen_path_xcconfig = "\"${PODS_ROOT}/../build/generated/ios\""
    pods_needing_codegen = ['RNSVG', 'RNScreens', 'RNCAsyncStorage', 'RNWorklets', 'RNReanimated']

    pods_needing_codegen.each do |pod_name|
      ['debug', 'release'].each do |config_type|
        xcconfig_path = "#{installer.sandbox.target_support_files_root}/#{pod_name}/#{pod_name}.#{config_type}.xcconfig"
        if File.exist?(xcconfig_path)
          content = File.read(xcconfig_path)
          unless content.include?('build/generated/ios')
            content = content.gsub(/^(HEADER_SEARCH_PATHS = .*)$/, "\\1 #{codegen_path_xcconfig}")
            File.write(xcconfig_path, content)
            Pod::UI.puts "Added codegen path to #{pod_name}: #{xcconfig_path}"
          end
        end
      end
    end

    # Fix App Clip: Remove excluded pods from linker flags
    # The exclude list doesn't properly remove these from OTHER_LDFLAGS
    excluded_libs = ['RNReanimated', 'RNWorklets']

    app_clip_xcconfig_dir = "#{installer.sandbox.target_support_files_root}/Pods-Nekt-NektClip"
    ['debug', 'release'].each do |config_type|
      xcconfig_path = "#{app_clip_xcconfig_dir}/Pods-Nekt-NektClip.#{config_type}.xcconfig"
      if File.exist?(xcconfig_path)
        content = File.read(xcconfig_path)

        # Remove excluded libraries from OTHER_LDFLAGS
        excluded_libs.each do |lib|
          content = content.gsub(/-l"#{lib}" /, '')
          content = content.gsub(/-l"#{lib}"/, '')
        end

        # Remove excluded libraries from LIBRARY_SEARCH_PATHS
        excluded_libs.each do |lib|
          content = content.gsub(/"\\$\{PODS_CONFIGURATION_BUILD_DIR\}\/#{lib}" /, '')
          content = content.gsub(/"\\$\{PODS_CONFIGURATION_BUILD_DIR\}\/#{lib}"/, '')
        end

        File.write(xcconfig_path, content)
        Pod::UI.puts "Fixed App Clip xcconfig: #{xcconfig_path}"
      end
    end
  end
end
